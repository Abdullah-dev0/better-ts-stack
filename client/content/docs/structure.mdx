---
title: Project Structure
description: Understanding the generated project structure and organization
icon: FolderTree
---

import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { Callout } from 'fumadocs-ui/components/callout';

## Overview

Better-TS-Stack generates a well-organized, scalable project structure following industry best practices. The exact structure depends on your selected options, but all projects share common organizational patterns.

## Full Stack Project

Here's the structure of a full-stack project with all features enabled:

<Files>
  <Folder name="my-app" defaultOpen>
    <Folder name="backend" defaultOpen>
      <Folder name="src">
        <Folder name="controllers">
          <File name="user.controller.ts" />
          <File name="auth.controller.ts" />
        </Folder>
        <Folder name="models">
          <File name="user.model.ts" />
        </Folder>
        <Folder name="routes">
          <File name="index.ts" />
          <File name="user.routes.ts" />
        </Folder>
        <Folder name="middleware">
          <File name="auth.middleware.ts" />
          <File name="error.middleware.ts" />
        </Folder>
        <Folder name="services">
          <File name="user.service.ts" />
          <File name="auth.service.ts" />
        </Folder>
        <Folder name="utils">
          <File name="logger.ts" />
          <File name="validation.ts" />
        </Folder>
        <File name="app.ts" />
        <File name="server.ts" />
      </Folder>
      <Folder name="tests">
        <File name="user.test.ts" />
        <File name="auth.test.ts" />
      </Folder>
      <File name="package.json" />
      <File name="tsconfig.json" />
      <File name=".env.example" />
    </Folder>
    <Folder name="frontend">
      <Folder name="src">
        <Folder name="components">
          <File name="Header.tsx" />
          <File name="Footer.tsx" />
        </Folder>
        <Folder name="pages">
          <File name="index.tsx" />
          <File name="about.tsx" />
        </Folder>
        <Folder name="hooks">
          <File name="useAuth.ts" />
        </Folder>
        <Folder name="services">
          <File name="api.ts" />
        </Folder>
        <Folder name="types">
          <File name="index.ts" />
        </Folder>
      </Folder>
      <File name="package.json" />
      <File name="tsconfig.json" />
    </Folder>
    <Folder name="shared">
      <Folder name="types">
        <File name="user.types.ts" />
        <File name="api.types.ts" />
      </Folder>
      <File name="package.json" />
    </Folder>
    <File name="docker-compose.yml" />
    <File name="docker-compose.dev.yml" />
    <File name=".gitignore" />
    <File name="README.md" />
    <File name="stack.config.ts" />
  </Folder>
</Files>

## Directory Breakdown

### Backend Structure

The backend follows a layered architecture pattern:

```typescript
backend/src/
├── controllers/     # Request handlers
├── models/          # Data models & schemas
├── routes/          # API route definitions
├── middleware/      # Express/Fastify middleware
├── services/        # Business logic layer
├── utils/           # Helper functions
├── app.ts           # App configuration
└── server.ts        # Server entry point
```

#### Controllers

Handle HTTP requests and responses. Keep them thin - delegate business logic to services.

```typescript title="backend/src/controllers/user.controller.ts"
import { Request, Response } from 'express';
import { UserService } from '../services/user.service';

export class UserController {
  constructor(private userService: UserService) {}

  async getUser(req: Request, res: Response) {
    const user = await this.userService.findById(req.params.id);
    return res.json(user);
  }

  async createUser(req: Request, res: Response) {
    const user = await this.userService.create(req.body);
    return res.status(201).json(user);
  }
}
```

#### Services

Contain business logic and interact with models/database.

```typescript title="backend/src/services/user.service.ts"
import { User } from '../models/user.model';
import { CreateUserDto } from '../types';

export class UserService {
  async findById(id: string): Promise<User | null> {
    return User.findByPk(id);
  }

  async create(data: CreateUserDto): Promise<User> {
    return User.create(data);
  }

  async update(id: string, data: Partial<CreateUserDto>): Promise<User> {
    const user = await this.findById(id);
    if (!user) throw new Error('User not found');
    return user.update(data);
  }
}
```

#### Routes

Define API endpoints and connect them to controllers.

```typescript title="backend/src/routes/user.routes.ts"
import { Router } from 'express';
import { UserController } from '../controllers/user.controller';
import { authMiddleware } from '../middleware/auth.middleware';

const router = Router();
const userController = new UserController();

router.get('/:id', authMiddleware, userController.getUser);
router.post('/', authMiddleware, userController.createUser);
router.put('/:id', authMiddleware, userController.updateUser);
router.delete('/:id', authMiddleware, userController.deleteUser);

export default router;
```

<Callout type="info" title="Middleware">
  Middleware functions run before your route handlers. Use them for authentication, validation, logging, etc.
</Callout>

### Frontend Structure

The frontend uses a component-based architecture:

```typescript
frontend/src/
├── components/      # Reusable UI components
├── pages/           # Page components (Next.js/React)
├── hooks/           # Custom React hooks
├── services/        # API communication
├── contexts/        # React context providers
├── types/           # TypeScript type definitions
└── utils/           # Helper functions
```

#### Components

Reusable UI building blocks:

```typescript title="frontend/src/components/UserCard.tsx"
import { User } from '@/types';

interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  onDelete?: (userId: string) => void;
}

export function UserCard({ user, onEdit, onDelete }: UserCardProps) {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <div className="actions">
        {onEdit && <button onClick={() => onEdit(user)}>Edit</button>}
        {onDelete && <button onClick={() => onDelete(user.id)}>Delete</button>}
      </div>
    </div>
  );
}
```

#### Custom Hooks

Encapsulate reusable logic:

```typescript title="frontend/src/hooks/useAuth.ts"
import { useState, useEffect } from 'react';
import { authService } from '@/services/auth';
import type { User } from '@/types';

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    checkAuth();
  }, []);

  async function checkAuth() {
    try {
      const currentUser = await authService.getCurrentUser();
      setUser(currentUser);
    } catch (error) {
      setUser(null);
    } finally {
      setLoading(false);
    }
  }

  async function login(email: string, password: string) {
    const user = await authService.login(email, password);
    setUser(user);
  }

  async function logout() {
    await authService.logout();
    setUser(null);
  }

  return { user, loading, login, logout };
}
```

### Shared Package

Share types and utilities between backend and frontend:

```typescript title="shared/types/user.types.ts"
export interface User {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateUserDto {
  email: string;
  name: string;
  password: string;
}

export interface UpdateUserDto {
  email?: string;
  name?: string;
}

export interface LoginDto {
  email: string;
  password: string;
}

export interface AuthResponse {
  user: User;
  token: string;
}
```

<Callout type="warn" title="Import Path">
  Configure path aliases in tsconfig.json to import shared types easily:
  ```json
  {
    "compilerOptions": {
      "paths": {
        "@shared/*": ["../shared/*"]
      }
    }
  }
  ```
</Callout>

## Configuration Files

### package.json

Each package has its own dependencies and scripts:

```json title="backend/package.json"
{
  "name": "backend",
  "version": "1.0.0",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "test": "vitest",
    "lint": "eslint src --ext .ts",
    "type:check": "tsc --noEmit"
  },
  "dependencies": {
    "express": "^4.18.0",
    "zod": "^3.22.0"
  }
}
```

### tsconfig.json

TypeScript configuration for type safety:

```json title="backend/tsconfig.json"
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### Docker Configuration

Multi-stage builds for optimized images:

```dockerfile title="backend/Dockerfile"
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package*.json ./
EXPOSE 3000
CMD ["node", "dist/server.js"]
```

## Best Practices

1. **Keep controllers thin** - Move business logic to services
2. **Use dependency injection** - Makes testing easier
3. **Shared types** - Use the shared package for API contracts
4. **Environment variables** - Never commit `.env` files
5. **Error handling** - Use centralized error middleware
6. **Validation** - Validate inputs at the route level
7. **Testing** - Write tests for services and critical paths

<Callout type="info" title="Monorepo">
  Consider using tools like Turborepo or Nx for managing multiple packages as your project grows.
</Callout>
